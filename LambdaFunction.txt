####################################################################
AdminMerchantUsersFunction
####################################################################

# import boto3
# import json
# from datetime import datetime
# import uuid
# import hashlib

# dynamodb = boto3.resource('dynamodb')
# table = dynamodb.Table('AdminMerchantUsers')

# def lambda_handler(event, context):
#     method = event['httpMethod']
    
#     if method == 'POST':
#         if event['path'] == '/register':
#             return register_user(event)
#         elif event['path'] == '/login':
#             return login_user(event)
    
#     elif method == 'GET':
#         user_id = event['pathParameters']['user_id']
#         return get_user(user_id)
    
#     elif method == 'PUT':
#         user_id = event['pathParameters']['user_id']
#         return update_user(user_id, event)
    
#     elif method == 'DELETE':
#         user_id = event['pathParameters']['user_id']
#         return delete_user(user_id)
    
#     return {
#         'statusCode': 400,
#         'body': json.dumps({'message': 'Invalid HTTP Method or Path'})
#     }


# # Register a new user (Admin or Merchant)
# def register_user(event):
#     data = json.loads(event['body'])
    
#     user_id = str(uuid.uuid4())
#     username = data['username']
#     email = data['email']
#     role = data['role']
#     password_hash = hashlib.sha256(data['password'].encode()).hexdigest()
#     created_at = datetime.utcnow().isoformat()

#     table.put_item(
#         Item={
#             'UserID': user_id,
#             'Username': username,
#             'Email': email,
#             'Role': role,
#             'PasswordHash': password_hash,
#             'CreatedAt': created_at
#         }
#     )
    
#     return {
#         'statusCode': 201,
#         'body': json.dumps({
#             'message': 'User registered successfully',
#             'user_id': user_id  # Change 'userID' to 'user_id'
#         })
#     }





# def login_user(event):
#     data = json.loads(event['body'])
#     username = data['username']
#     password = data['password']
#     password_hash = hashlib.sha256(password.encode()).hexdigest()

#     # Query by username (you may need to create an index for querying by username in DynamoDB)
#     response = table.scan(
#         FilterExpression="Username = :username",
#         ExpressionAttributeValues={":username": username}
#     )
    
#     if 'Items' in response and len(response['Items']) > 0:
#         user = response['Items'][0]

#         if user['PasswordHash'] == password_hash:
#             return {
#                 'statusCode': 200,
#                 'body': json.dumps({
#                     'message': 'Login successful',
#                     'user_id': user['UserID'],
#                     'role': user['Role']  # Ensure role is returned here
#                 })
#             }
#         else:
#             return {
#                 'statusCode': 401,
#                 'body': json.dumps({'message': 'Invalid password'})
#             }
#     else:
#         return {
#             'statusCode': 404,
#             'body': json.dumps({'message': 'User not found'})
#         }




# # Get user details by user_id
# def get_user(user_id):
#     response = table.get_item(
#         Key={'UserID': user_id}
#     )
    
#     if 'Item' in response:
#         return {
#             'statusCode': 200,
#             'body': json.dumps(response['Item'])
#         }
#     else:
#         return {
#             'statusCode': 404,
#             'body': json.dumps({'message': 'User not found'})
#         }

# # Update user details by user_id
# def update_user(user_id, event):
#     data = json.loads(event['body'])
    
#     update_expression = "SET "
#     expression_attributes = {}
    
#     if 'username' in data:
#         update_expression += "Username = :username, "
#         expression_attributes[':username'] = data['username']
#     if 'email' in data:
#         update_expression += "Email = :email, "
#         expression_attributes[':email'] = data['email']
#     if 'role' in data:
#         update_expression += "Role = :role, "
#         expression_attributes[':role'] = data['role']
    
#     update_expression = update_expression.rstrip(", ")
    
#     table.update_item(
#         Key={'UserID': user_id},
#         UpdateExpression=update_expression,
#         ExpressionAttributeValues=expression_attributes
#     )
    
#     return {
#         'statusCode': 200,
#         'body': json.dumps({'message': 'User updated successfully'})
#     }

# # Delete user by user_id
# def delete_user(user_id):
#     table.delete_item(
#         Key={'UserID': user_id}
#     )
    
#     return {
#         'statusCode': 200,
#         'body': json.dumps({'message': 'User deleted successfully'})
#     }



import boto3
import json
from datetime import datetime
import uuid
import hashlib

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('AdminMerchantUsers')

def lambda_handler(event, context):
    method = event['httpMethod']
    
    if method == 'POST':
        if event['path'] == '/register':
            return register_user(event)
        elif event['path'] == '/login':
            return login_user(event)
    
    elif method == 'GET':
        if event['path'] == '/users':
            return get_all_users()  # Call the function to get all users
        else:
            user_id = event['pathParameters']['user_id']
            return get_user(user_id)
    
    elif method == 'PUT':
        user_id = event['pathParameters']['user_id']
        return update_user(user_id, event)
    
    elif method == 'DELETE':
        user_id = event['pathParameters']['user_id']
        return delete_user(user_id)
    
    return {
        'statusCode': 400,
        'body': json.dumps({'message': 'Invalid HTTP Method or Path'})
    }


# Register a new user (Admin or Merchant)
def register_user(event):
    data = json.loads(event['body'])
    
    user_id = str(uuid.uuid4())
    username = data['username']
    email = data['email']
    role = data['role']
    password_hash = hashlib.sha256(data['password'].encode()).hexdigest()
    created_at = datetime.utcnow().isoformat()

    table.put_item(
        Item={
            'UserID': user_id,
            'Username': username,
            'Email': email,
            'Role': role,
            'PasswordHash': password_hash,
            'CreatedAt': created_at
        }
    )
    
    return {
        'statusCode': 201,
        'body': json.dumps({
            'message': 'User registered successfully',
            'user_id': user_id  # Return the user_id in the response
        })
    }


# User login (validate username and password)
def login_user(event):
    data = json.loads(event['body'])
    username = data['username']
    password = data['password']
    password_hash = hashlib.sha256(password.encode()).hexdigest()

    # Query by username (you may need to create an index for querying by username in DynamoDB)
    response = table.scan(
        FilterExpression="Username = :username",
        ExpressionAttributeValues={":username": username}
    )
    
    if 'Items' in response and len(response['Items']) > 0:
        user = response['Items'][0]

        if user['PasswordHash'] == password_hash:
            return {
                'statusCode': 200,
                'body': json.dumps({
                    'message': 'Login successful',
                    'user_id': user['UserID'],
                    'role': user['Role']  # Return the role in the response
                })
            }
        else:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': 'Invalid password'})
            }
    else:
        return {
            'statusCode': 404,
            'body': json.dumps({'message': 'User not found'})
        }


# Get user details by user_id
def get_user(user_id):
    response = table.get_item(
        Key={'UserID': user_id}
    )
    
    if 'Item' in response:
        return {
            'statusCode': 200,
            'body': json.dumps(response['Item'])
        }
    else:
        return {
            'statusCode': 404,
            'body': json.dumps({'message': 'User not found'})
        }


# Get all users from the DynamoDB table
def get_all_users():
    try:
        response = table.scan()  # Scan the table to get all users
        users = response.get('Items', [])
        
        return {
            'statusCode': 200,
            'body': json.dumps(users)
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f'Error fetching users: {str(e)}'})
        }


# # Update user details by user_id
# def update_user(user_id, event):
#     data = json.loads(event['body'])
    
#     update_expression = "SET "
#     expression_attributes = {}
    
#     if 'username' in data:
#         update_expression += "Username = :username, "
#         expression_attributes[':username'] = data['username']
#     if 'email' in data:
#         update_expression += "Email = :email, "
#         expression_attributes[':email'] = data['email']
#     if 'role' in data:
#         update_expression += "Role = :role, "
#         expression_attributes[':role'] = data['role']
    
#     update_expression = update_expression.rstrip(", ")
    
#     table.update_item(
#         Key={'UserID': user_id},
#         UpdateExpression=update_expression,
#         ExpressionAttributeValues=expression_attributes
#     )
    
#     return {
#         'statusCode': 200,
#         'body': json.dumps({'message': 'User updated successfully'})
#     }

# Update user details by user_id
def update_user(user_id, event):
    data = json.loads(event['body'])
    
    update_expression = "SET "
    expression_attributes = {}
    expression_attribute_names = {}  # To handle reserved keywords
    
    if 'username' in data:
        update_expression += "Username = :username, "
        expression_attributes[':username'] = data['username']
    if 'email' in data:
        update_expression += "Email = :email, "
        expression_attributes[':email'] = data['email']
    if 'role' in data:
        # Use a placeholder for Role as it's a reserved keyword
        update_expression += "#role = :role, "
        expression_attributes[':role'] = data['role']
        expression_attribute_names['#role'] = 'Role'  # Map the placeholder to the actual attribute name
    
    update_expression = update_expression.rstrip(", ")

    # Debugging print statements
    print(f"Update Expression: {update_expression}")
    print(f"Expression Attributes: {expression_attributes}")
    print(f"Expression Attribute Names: {expression_attribute_names}")
    
    # Update DynamoDB table
    table.update_item(
        Key={'UserID': user_id},
        UpdateExpression=update_expression,
        ExpressionAttributeValues=expression_attributes,
        ExpressionAttributeNames=expression_attribute_names  # Use attribute names to handle reserved keyword
    )
    
    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'User updated successfully'})
    }




# Delete user by user_id
def delete_user(user_id):
    table.delete_item(
        Key={'UserID': user_id}
    )
    
    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'User deleted successfully'})
    }







####################################################################
ProductServiceFunction
####################################################################
# import json
# import boto3
# from decimal import Decimal

# dynamodb = boto3.resource('dynamodb')
# table = dynamodb.Table('Products')

# # Helper function to convert Decimal to float
# def decimal_to_float(item):
#     if isinstance(item, list):
#         return [decimal_to_float(i) for i in item]
#     elif isinstance(item, dict):
#         return {k: decimal_to_float(v) for k, v in item.items()}
#     elif isinstance(item, Decimal):
#         return float(item)
#     else:
#         return item

# def lambda_handler(event, context):
#     # query = event.get('queryStringParameters', {}).get('search', '').lower()
#     # # Filter products based on the query
#     # if query:
#     #     items = [item for item in items if query in item['ProductName'].lower()]
    
    
    
#     try:
#         method = event['httpMethod']
#         if method == 'GET':
#             # Check if we are fetching a specific product by ID
#             if 'pathParameters' in event and event['pathParameters'] and 'product_id' in event['pathParameters']:
#                 product_id = event['pathParameters']['product_id']
#                 return get_product_by_id(product_id)
#             else:
#                 return get_all_products()

#         elif method == 'POST':
#             return add_product(event)

#         else:
#             return {
#                 'statusCode': 400,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*'
#                 },
#                 'body': json.dumps({'message': 'Unsupported HTTP method'})
#             }

#     except Exception as e:
#         return {
#             'statusCode': 500,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': f"Error processing request: {str(e)}"})
#         }





# # Function to add a product
# def add_product(event):
#     body = json.loads(event['body'])
#     product_id = body.get('ProductID')
#     product_name = body.get('ProductName')
#     price = Decimal(str(body.get('Price')))
#     description = body.get('Description', '')
#     image_url = body.get('ImageUrl', '')

#     if not product_id or not product_name or price is None:
#         return {
#             'statusCode': 400,
#             'body': json.dumps({'message': 'ProductID, ProductName, and Price are required'})
#         }

#     table.put_item(
#         Item={
#             'ProductID': product_id,
#             'ProductName': product_name,
#             'Price': price,
#             'Description': description,
#             'ImageUrl': image_url
#         }
#     )

#     return {
#         'statusCode': 201,
#         'headers': {
#             'Access-Control-Allow-Origin': '*'
#         },
#         'body': json.dumps({'message': 'Product added successfully'})
#     }

# # Function to retrieve all products
# def get_all_products():
#     response = table.scan()
#     products = response.get('Items', [])
#     products = decimal_to_float(products)  # Convert any Decimal values to float

#     return {
#         'statusCode': 200,
#         'headers': {
#             'Access-Control-Allow-Origin': '*',
#             'Content-Type': 'application/json'
#         },
#         'body': json.dumps(products)
#     }

# # Function to retrieve a product by its ID
# def get_product_by_id(product_id):
#     response = table.get_item(Key={'ProductID': product_id})
#     product = response.get('Item', None)

#     if product:
#         product = decimal_to_float(product)  # Convert Decimal values to float
#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Content-Type': 'application/json'
#             },
#             'body': json.dumps(product)
#         }
#     else:
#         return {
#             'statusCode': 404,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': 'Product not found'})
#         }



######################################################################
# import json
# import boto3
# from decimal import Decimal

# dynamodb = boto3.resource('dynamodb')
# table = dynamodb.Table('Products')

# # Helper function to convert Decimal to float
# def decimal_to_float(item):
#     if isinstance(item, list):
#         return [decimal_to_float(i) for i in item]
#     elif isinstance(item, dict):
#         return {k: decimal_to_float(v) for k, v in item.items()}
#     elif isinstance(item, Decimal):
#         return float(item)
#     else:
#         return item

# def lambda_handler(event, context):
#     try:
#         method = event['httpMethod']
#         if method == 'GET':
#             # Check if we are fetching a specific product by ID
#             if 'pathParameters' in event and event['pathParameters'] and 'product_id' in event['pathParameters']:
#                 product_id = event['pathParameters']['product_id']
#                 return get_product_by_id(product_id)
#             else:
#                 return get_all_products()

#         elif method == 'POST':
#             return add_product(event)

#         elif method == 'DELETE':
#             # Handle DELETE requests
#             if 'pathParameters' in event and event['pathParameters'] and 'product_id' in event['pathParameters']:
#                 product_id = event['pathParameters']['product_id']
#                 return delete_product(product_id)
#             else:
#                 return {
#                     'statusCode': 400,
#                     'headers': {
#                         'Access-Control-Allow-Origin': '*'
#                     },
#                     'body': json.dumps({'message': 'ProductID is required for deletion'})
#                 }

#         else:
#             return {
#                 'statusCode': 400,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*'
#                 },
#                 'body': json.dumps({'message': 'Unsupported HTTP method'})
#             }

#     except Exception as e:
#         return {
#             'statusCode': 500,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': f"Error processing request: {str(e)}"})
#         }

# # Function to add a product
# def add_product(event):
#     body = json.loads(event['body'])
#     product_id = body.get('ProductID')
#     product_name = body.get('ProductName')
#     price = Decimal(str(body.get('Price')))
#     description = body.get('Description', '')
#     image_url = body.get('ImageUrl', '')

#     if not product_id or not product_name or price is None:
#         return {
#             'statusCode': 400,
#             'body': json.dumps({'message': 'ProductID, ProductName, and Price are required'})
#         }

#     table.put_item(
#         Item={
#             'ProductID': product_id,
#             'ProductName': product_name,
#             'Price': price,
#             'Description': description,
#             'ImageUrl': image_url
#         }
#     )

#     return {
#         'statusCode': 201,
#         'headers': {
#             'Access-Control-Allow-Origin': '*'
#         },
#         'body': json.dumps({'message': 'Product added successfully'})
#     }

# # Function to retrieve all products
# def get_all_products():
#     response = table.scan()
#     products = response.get('Items', [])
#     products = decimal_to_float(products)  # Convert any Decimal values to float

#     return {
#         'statusCode': 200,
#         'headers': {
#             'Access-Control-Allow-Origin': '*',
#             'Content-Type': 'application/json'
#         },
#         'body': json.dumps(products)
#     }

# # Function to retrieve a product by its ID
# def get_product_by_id(product_id):
#     response = table.get_item(Key={'ProductID': product_id})
#     product = response.get('Item', None)

#     if product:
#         product = decimal_to_float(product)  # Convert Decimal values to float
#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Content-Type': 'application/json'
#             },
#             'body': json.dumps(product)
#         }
#     else:
#         return {
#             'statusCode': 404,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': 'Product not found'})
#         }

# # Function to delete a product by its ID
# def delete_product(product_id):
#     try:
#         # Check if the product exists before trying to delete it
#         response = table.get_item(Key={'ProductID': product_id})
#         if 'Item' not in response:
#             return {
#                 'statusCode': 404,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*'
#                 },
#                 'body': json.dumps({'message': 'Product not found'})
#             }

#         # Delete the product
#         table.delete_item(Key={'ProductID': product_id})

#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': 'Product deleted successfully'})
#         }

#     except Exception as e:
#         return {
#             'statusCode': 500,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': f"Error deleting product: {str(e)}"})
#         }

# ###################################################################
# import json
# import boto3
# from decimal import Decimal

# dynamodb = boto3.resource('dynamodb')
# table = dynamodb.Table('Products')

# # Helper function to convert Decimal to float
# def decimal_to_float(item):
#     if isinstance(item, list):
#         return [decimal_to_float(i) for i in item]
#     elif isinstance(item, dict):
#         return {k: decimal_to_float(v) for k, v in item.items()}
#     elif isinstance(item, Decimal):
#         return float(item)
#     else:
#         return item

# def lambda_handler(event, context):
#     try:
#         method = event['httpMethod']
#         if method == 'GET':
#             # Check if we are fetching a specific product by ID
#             if 'pathParameters' in event and event['pathParameters'] and 'product_id' in event['pathParameters']:
#                 product_id = event['pathParameters']['product_id']
#                 return get_product_by_id(product_id)
#             else:
#                 return get_all_products()

#         elif method == 'POST':
#             return add_product(event)

#         elif method == 'DELETE':
#             # Handle DELETE requests
#             if 'pathParameters' in event and event['pathParameters'] and 'product_id' in event['pathParameters']:
#                 product_id = event['pathParameters']['product_id']
#                 return delete_product(product_id)
#             else:
#                 return {
#                     'statusCode': 400,
#                     'headers': {
#                         'Access-Control-Allow-Origin': '*'
#                     },
#                     'body': json.dumps({'message': 'ProductID is required for deletion'})
#                 }

#         elif method == 'PUT':
#             # Handle PUT requests (Update product)
#             if 'pathParameters' in event and event['pathParameters'] and 'product_id' in event['pathParameters']:
#                 product_id = event['pathParameters']['product_id']
#                 return update_product(product_id, event)
#             else:
#                 return {
#                     'statusCode': 400,
#                     'headers': {
#                         'Access-Control-Allow-Origin': '*'
#                     },
#                     'body': json.dumps({'message': 'ProductID is required for updating'})
#                 }

#         else:
#             return {
#                 'statusCode': 400,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*'
#                 },
#                 'body': json.dumps({'message': 'Unsupported HTTP method'})
#             }

#     except Exception as e:
#         return {
#             'statusCode': 500,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': f"Error processing request: {str(e)}"})
#         }

# # Function to add a product
# def add_product(event):
#     body = json.loads(event['body'])
#     product_id = body.get('ProductID')
#     product_name = body.get('ProductName')
#     price = Decimal(str(body.get('Price')))
#     description = body.get('Description', '')
#     image_url = body.get('ImageUrl', '')

#     if not product_id or not product_name or price is None:
#         return {
#             'statusCode': 400,
#             'body': json.dumps({'message': 'ProductID, ProductName, and Price are required'})
#         }

#     table.put_item(
#         Item={
#             'ProductID': product_id,
#             'ProductName': product_name,
#             'Price': price,
#             'Description': description,
#             'ImageUrl': image_url
#         }
#     )

#     return {
#         'statusCode': 201,
#         'headers': {
#             'Access-Control-Allow-Origin': '*'
#         },
#         'body': json.dumps({'message': 'Product added successfully'})
#     }

# # Function to update a product by its ID
# def update_product(product_id, event):
#     body = json.loads(event['body'])
    
#     update_expression = "SET "
#     expression_attributes = {}
    
#     if 'ProductName' in body:
#         update_expression += "ProductName = :product_name, "
#         expression_attributes[':product_name'] = body['ProductName']
#     if 'Description' in body:
#         update_expression += "Description = :description, "
#         expression_attributes[':description'] = body['Description']
#     if 'ImageUrl' in body:
#         update_expression += "ImageUrl = :image_url, "
#         expression_attributes[':image_url'] = body['ImageUrl']
#     if 'Price' in body:
#         update_expression += "Price = :price, "
#         expression_attributes[':price'] = Decimal(str(body['Price']))
    
#     # Remove the last comma and space
#     update_expression = update_expression.rstrip(", ")

#     try:
#         # Update the product in DynamoDB
#         table.update_item(
#             Key={'ProductID': product_id},
#             UpdateExpression=update_expression,
#             ExpressionAttributeValues=expression_attributes
#         )

#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': 'Product updated successfully'})
#         }

#     except Exception as e:
#         return {
#             'statusCode': 500,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': f"Error updating product: {str(e)}"})
#         }

# # Function to retrieve all products
# def get_all_products():
#     response = table.scan()
#     products = response.get('Items', [])
#     products = decimal_to_float(products)  # Convert any Decimal values to float

#     return {
#         'statusCode': 200,
#         'headers': {
#             'Access-Control-Allow-Origin': '*',
#             'Content-Type': 'application/json'
#         },
#         'body': json.dumps(products)
#     }

# # Function to retrieve a product by its ID
# def get_product_by_id(product_id):
#     response = table.get_item(Key={'ProductID': product_id})
#     product = response.get('Item', None)

#     if product:
#         product = decimal_to_float(product)  # Convert Decimal values to float
#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Content-Type': 'application/json'
#             },
#             'body': json.dumps(product)
#         }
#     else:
#         return {
#             'statusCode': 404,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': 'Product not found'})
#         }

# # Function to delete a product by its ID
# def delete_product(product_id):
#     try:
#         # Check if the product exists before trying to delete it
#         response = table.get_item(Key={'ProductID': product_id})
#         if 'Item' not in response:
#             return {
#                 'statusCode': 404,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*'
#                 },
#                 'body': json.dumps({'message': 'Product not found'})
#             }

#         # Delete the product
#         table.delete_item(Key={'ProductID': product_id})

#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': 'Product deleted successfully'})
#         }

#     except Exception as e:
#         return {
#             'statusCode': 500,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*'
#             },
#             'body': json.dumps({'message': f"Error deleting product: {str(e)}"})
#         }



#######################################################################
import json
import boto3
from decimal import Decimal

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Products')

# Helper function to convert Decimal to float
def decimal_to_float(item):
    if isinstance(item, list):
        return [decimal_to_float(i) for i in item]
    elif isinstance(item, dict):
        return {k: decimal_to_float(v) for k, v in item.items()}
    elif isinstance(item, Decimal):
        return float(item)
    else:
        return item

def lambda_handler(event, context):
    try:
        method = event.get('httpMethod', None)
        if not method:
            raise Exception("HTTP method not provided in the event")

        if method == 'GET':
            # Check if we are fetching a specific product by ID
            if event.get('pathParameters') and 'product_id' in event['pathParameters']:
                product_id = event['pathParameters']['product_id']
                return get_product_by_id(product_id)

            # Check if we are filtering by merchant_id
            elif event.get('queryStringParameters') and 'merchant_id' in event['queryStringParameters']:
                merchant_id = event['queryStringParameters']['merchant_id']
                return get_products_by_merchant(merchant_id)

            else:
                return get_all_products()

        elif method == 'POST':
            return add_product(event)

        elif method == 'DELETE':
            # Handle DELETE requests
            if event.get('pathParameters') and 'product_id' in event['pathParameters']:
                product_id = event['pathParameters']['product_id']
                return delete_product(product_id)
            else:
                return {
                    'statusCode': 400,
                    'headers': {
                        'Access-Control-Allow-Origin': '*'
                    },
                    'body': json.dumps({'message': 'ProductID is required for deletion'})
                }

        elif method == 'PUT':
            # Handle PUT requests (Update product)
            if event.get('pathParameters') and 'product_id' in event['pathParameters']:
                product_id = event['pathParameters']['product_id']
                return update_product(product_id, event)
            else:
                return {
                    'statusCode': 400,
                    'headers': {
                        'Access-Control-Allow-Origin': '*'
                    },
                    'body': json.dumps({'message': 'ProductID is required for updating'})
                }

        else:
            return {
                'statusCode': 400,
                'headers': {
                    'Access-Control-Allow-Origin': '*'
                },
                'body': json.dumps({'message': 'Unsupported HTTP method'})
            }

    except Exception as e:
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': f"Error processing request: {str(e)}"})
        }

# Function to retrieve products by merchant_id
def get_products_by_merchant(merchant_id):
    try:
        # Filter products by MerchantID
        response = table.scan(
            FilterExpression=boto3.dynamodb.conditions.Attr('MerchantID').eq(merchant_id)
        )
        products = response.get('Items', [])
        products = decimal_to_float(products)  # Convert Decimal values to float

        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Content-Type': 'application/json'
            },
            'body': json.dumps(products)
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': f"Error fetching products for merchant: {str(e)}"})
        }

# Function to add a product
def add_product(event):
    body = json.loads(event['body'])
    product_id = body.get('ProductID')
    product_name = body.get('ProductName')
    price = Decimal(str(body.get('Price')))
    description = body.get('Description', '')
    image_url = body.get('ImageUrl', '')
    merchant_id = body.get('MerchantID') 
    merchant_name = body.get('MerchantName')

    if not product_id or not product_name or price is None or not merchant_id:
        return {
            'statusCode': 400,
            'body': json.dumps({'message': 'ProductID, ProductName, Price, and MerchantID are required'})
        }

    table.put_item(
        Item={
            'ProductID': product_id,
            'ProductName': product_name,
            'Price': price,
            'Description': description,
            'ImageUrl': image_url,
            'MerchantID': merchant_id,
            'MerchantName': merchant_name
        }
    )

    return {
        'statusCode': 201,
        'headers': {
            'Access-Control-Allow-Origin': '*'
        },
        'body': json.dumps({'message': 'Product added successfully'})
    }

# Function to update a product by its ID
def update_product(product_id, event):
    body = json.loads(event['body'])
    
    update_expression = "SET "
    expression_attributes = {}
    
    if 'ProductName' in body:
        update_expression += "ProductName = :product_name, "
        expression_attributes[':product_name'] = body['ProductName']
    if 'Description' in body:
        update_expression += "Description = :description, "
        expression_attributes[':description'] = body['Description']
    if 'ImageUrl' in body:
        update_expression += "ImageUrl = :image_url, "
        expression_attributes[':image_url'] = body['ImageUrl']
    if 'Price' in body:
        update_expression += "Price = :price, "
        expression_attributes[':price'] = Decimal(str(body['Price']))
    
    # Remove the last comma and space
    update_expression = update_expression.rstrip(", ")

    try:
        # Update the product in DynamoDB
        table.update_item(
            Key={'ProductID': product_id},
            UpdateExpression=update_expression,
            ExpressionAttributeValues=expression_attributes
        )

        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': 'Product updated successfully'})
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': f"Error updating product: {str(e)}"})
        }

# Function to retrieve all products
def get_all_products():
    response = table.scan()
    products = response.get('Items', [])
    products = decimal_to_float(products)  # Convert any Decimal values to float

    return {
        'statusCode': 200,
        'headers': {
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json'
        },
        'body': json.dumps(products)
    }

# Function to retrieve a product by its ID
def get_product_by_id(product_id):
    response = table.get_item(Key={'ProductID': product_id})
    product = response.get('Item', None)

    if product:
        product = decimal_to_float(product)  # Convert Decimal values to float
        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Content-Type': 'application/json'
            },
            'body': json.dumps(product)
        }
    else:
        return {
            'statusCode': 404,
            'headers': {
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': 'Product not found'})
        }

# Function to delete a product by its ID
def delete_product(product_id):
    try:
        # Check if the product exists before trying to delete it
        response = table.get_item(Key={'ProductID': product_id})
        if 'Item' not in response:
            return {
                'statusCode': 404,
                'headers': {
                    'Access-Control-Allow-Origin': '*'
                },
                'body': json.dumps({'message': 'Product not found'})
            }

        # Delete the product
        table.delete_item(Key={'ProductID': product_id})

        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': 'Product deleted successfully'})
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'headers': {
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': f"Error deleting product: {str(e)}"})
        }


####################################################################
OrderServiceFunction2
####################################################################
import json  # Import json to handle JSON operations
import boto3
from boto3.dynamodb.conditions import Key
from decimal import Decimal
import uuid  
from datetime import datetime
from boto3.dynamodb.conditions import Attr 

# Initialize DynamoDB resource for the Orders2 table
dynamodb = boto3.resource('dynamodb')
orders_table = dynamodb.Table('Orders2')



def lambda_handler(event, context):
    http_method = event['httpMethod']
    path = event['path']
    
    try:
        # POST /ecommerce/order: Create an order
        if http_method == 'POST' and path == '/ecommerce/order':
            return create_order(event)
        
        # GET /ecommerce/order/{user_id}: Get user order history
        elif http_method == 'GET' and '/ecommerce/order/' in path:
            user_id = event['pathParameters'].get('user_id')
            if user_id:
                return get_user_order_history(user_id)
            else:
                return {
                    'statusCode': 400,
                    'body': json.dumps({'message': 'user_id is missing in path parameters'})
                }

        # GET /cms/admin/orders: Get all orders for admin
        elif http_method == 'GET' and path == '/cms/admin/orders':
            return get_all_orders()

        # GET /cms/merchant/orders/{merchant_id}: Get all orders for a specific merchant
        elif http_method == 'GET' and '/cms/merchant/orders/' in path:
            merchant_id = event['pathParameters'].get('merchant_id')
            if merchant_id:
                return get_merchant_orders(merchant_id)
            else:
                return {
                    'statusCode': 400,
                    'body': json.dumps({'message': 'merchant_id is missing in path parameters'})
                }
                
        elif http_method == 'GET' and '/cms/merchant/orders/' in path:
            merchant_id = event['pathParameters'].get('merchant_id')
            order_id = event['pathParameters'].get('order_id')
            if merchant_id and order_id:
                return get_order_details_by_merchant_and_order_id(merchant_id, order_id)
            else:
                return {
                    'statusCode': 400,
                    'body': json.dumps({'message': 'merchant_id or order_id is missing in path parameters'})
                }


        # GET /cms/admin/orders/{order_id}: Get order details by order_id
        elif http_method == 'GET' and '/cms/admin/orders/' in path:
            order_id = event['pathParameters'].get('order_id')
            if order_id:
                return get_order_details_by_order_id(order_id)
            else:
                return {
                    'statusCode': 400,
                    'body': json.dumps({'message': 'order_id is missing in path parameters'})
                }
                

        # DELETE /cms/admin/orders/{order_id}: Delete an order by order_id
        elif http_method == 'DELETE' and '/cms/admin/orders/' in path:
            order_id = event['pathParameters'].get('order_id')
            if order_id:
                return delete_order(order_id)
            else:
                return {
                    'statusCode': 400,
                    'body': json.dumps({'message': 'order_id is missing in path parameters'})
                }


        
        # DELETE /cms/merchant/orders/{merchant_id}/{order_id}: Delete an order by order_id for a merchant
        elif http_method == 'DELETE' and '/cms/merchant/orders/' in path:
            merchant_id = event['pathParameters'].get('merchant_id')
            order_id = event['pathParameters'].get('order_id')
            
            if merchant_id and order_id:
                return delete_merchant_order(merchant_id, order_id)
            else:
                return {
                    'statusCode': 400,
                    'body': json.dumps({'message': 'merchant_id or order_id is missing in path parameters'})
                }
        else:
            return {
                'statusCode': 400,
                'body': json.dumps({'message': 'Invalid request path or method'})
            }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'An error occurred', 'error': str(e)})
        }

# Function to get order details by OrderID
def get_order_details_by_order_id(order_id):
    try:
        # Scan the table to find the order by OrderID
        response = orders_table.scan(
            FilterExpression=Attr('OrderID').eq(order_id)
        )
        
        # If the order is found, return it
        if 'Items' in response and response['Items']:
            return {
                'statusCode': 200,
                'body': json.dumps(response['Items'], default=decimal_default)
            }
        else:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': 'Order not found'})
            }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'Error fetching order details', 'error': str(e)})
        }

# Function to get order details by merchant_id and order_id
def get_order_details_by_merchant_and_order_id(merchant_id, order_id):
    try:
        # Scan the table to find the order with the specified OrderID
        response = orders_table.scan(
            FilterExpression=Attr('OrderID').eq(order_id)
        )
        
        # If the order is found, filter by MerchantID within the CartItems
        if 'Items' in response and response['Items']:
            order = response['Items'][0]
            
            # Check if the MerchantID is present in the CartItems
            merchant_items = [item for item in order['CartItems'] if item['MerchantID'] == merchant_id]
            
            if merchant_items:
                # Return the filtered order details for the specific merchant
                return {
                    'statusCode': 200,
                    'body': json.dumps({
                        'OrderID': order['OrderID'],
                        'UserID': order['UserID'],
                        'ShippingAddress': order['ShippingAddress'],
                        'OrderDate': order['OrderDate'],
                        'TotalPrice': order['TotalPrice'],
                        'OrderStatus': order['OrderStatus'],
                        'MerchantItems': merchant_items  # Return only the merchant's items
                    }, default=decimal_default)
                }
            else:
                return {
                    'statusCode': 404,
                    'body': json.dumps({'message': 'No items found for the specified merchant in this order'})
                }
        else:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': 'Order not found'})
            }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'Error fetching order details', 'error': str(e)})
        }

# Custom function to convert DynamoDB items to JSON serializable types
def decimal_default(obj):
    if isinstance(obj, Decimal):
        return float(obj)
    raise TypeError




# Function to get the order history of a specific user using GSI (Global Secondary Index)
def get_user_order_history(user_id):
    # Query the Orders2 table using the GSI for user_id
    response = orders_table.query(
        IndexName='UserID-index',  # GSI name created for user_id
        KeyConditionExpression=Key('UserID').eq(user_id)
    )
    
    # Return the list of orders for the user
    return {
        'statusCode': 200,
        'body': json.dumps(response['Items'], default=decimal_default)
    }



# Function to get all orders for admin
def get_all_orders():
    response = orders_table.scan()
    return {
        'statusCode': 200,
        'body': json.dumps(response['Items'], default=decimal_default)
    }

# Function to get all orders for a specific merchant by MerchantID in CartItems
def get_merchant_orders(merchant_id):
    try:
        # Scan the Orders2 table to find all orders
        response = orders_table.scan()
        orders = response.get('Items', [])
        
        # Filter orders by checking if the MerchantID exists in any of the CartItems
        merchant_orders = []
        for order in orders:
            for item in order.get('CartItems', []):
                if item.get('MerchantID') == merchant_id:
                    merchant_orders.append(order)
                    break  # If one item in the order belongs to the merchant, no need to check other items

        if merchant_orders:
            return {
                'statusCode': 200,
                'body': json.dumps(merchant_orders, default=decimal_default)
            }
        else:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': 'No orders found for the merchant'})
            }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'Error fetching orders for merchant', 'error': str(e)})
        }



# Function to create an order and store cart item information
def create_order(event):
    body = json.loads(event['body'])
    
    user_id = body['UserID']  # Use PascalCase for user_id
    # product_ids = body['ProductIDs']  # Use PascalCase for product_ids
    # merchant_id = body['MerchantID']  # Use PascalCase for merchant_id
    total_price = Decimal(str(body['TotalPrice']))  # Convert total_price to Decimal
    shipping_address = body['ShippingAddress']  # Use PascalCase for shipping_info
    
    # Add the cart items to the order body
    cart_items = body.get('CartItems', [])  # Get the cart items from the body
    
    # Validate that CartItems is not empty
    if not cart_items:
        return {
            'statusCode': 400,
            'body': json.dumps({'message': 'Cart items cannot be empty'})
        }

    # Convert price and quantity in each cart item to Decimal and int respectively
    for item in cart_items:
        item['Price'] = Decimal(str(item['Price']))  # Ensure Price is stored as Decimal
        item['Quantity'] = int(item['Quantity'])  # Ensure Quantity is stored as int

    # Generate a unique order ID
    order_id = str(uuid.uuid4())
    order_date = str(datetime.utcnow())
    
    # Build the order item including cart details
    order_item = {
        'OrderID': order_id,        # Partition Key
        'UserID': user_id,          # Sort Key
        # 'ProductIDs': product_ids,
        # 'MerchantID': merchant_id,
        'TotalPrice': total_price,
        'OrderStatus': 'pending',   # Use PascalCase for status
        'ShippingAddress': shipping_address,
        'OrderDate': order_date,
        'CartItems': cart_items  # Include the cart items in the order
    }
    
    # Insert the order into DynamoDB
    orders_table.put_item(Item=order_item)
    
    return {
        'statusCode': 201,
        'body': json.dumps({
            'message': 'Order created successfully',
            'OrderID': order_id  # Return OrderID using PascalCase
        })
    }

# Function to delete an order by OrderID
def delete_order(order_id):
    try:
        # First, scan to find the order and retrieve UserID
        response = orders_table.scan(
            FilterExpression=Attr('OrderID').eq(order_id)
        )
        
        items = response.get('Items', [])
        if not items:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': 'Order not found'})
            }
        
        # Assuming OrderID is unique and there's only one item
        order = items[0]
        user_id = order.get('UserID')
        
        if not user_id:
            return {
                'statusCode': 400,
                'body': json.dumps({'message': 'UserID not found for the order'})
            }
        
        # Delete the order using both OrderID and UserID
        delete_response = orders_table.delete_item(
            Key={
                'OrderID': order_id,
                'UserID': user_id
            }
        )
        
        return {
            'statusCode': 200,
            'body': json.dumps({'message': f'Order {order_id} deleted successfully.'})
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'Error deleting order', 'error': str(e)})
        }

# Function to delete an order for a merchant by OrderID and MerchantID
def delete_merchant_order(merchant_id, order_id):
    try:
        # Scan to find the order by OrderID
        response = orders_table.scan(
            FilterExpression=Attr('OrderID').eq(order_id)
        )
        
        items = response.get('Items', [])
        if not items:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': 'Order not found'})
            }
        
        # Get the order and check if the merchant has items in this order
        order = items[0]
        merchant_items = [item for item in order['CartItems'] if item['MerchantID'] == merchant_id]
        
        if not merchant_items:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': 'No items found for the specified merchant in this order'})
            }
        
        # If all items in the order belong to the merchant, delete the entire order
        if len(merchant_items) == len(order['CartItems']):
            # Delete the order using both OrderID and UserID
            user_id = order.get('UserID')
            orders_table.delete_item(
                Key={
                    'OrderID': order_id,
                    'UserID': user_id
                }
            )
            return {
                'statusCode': 200,
                'body': json.dumps({'message': f'Order {order_id} deleted successfully.'})
            }
        else:
            # Remove only the merchant's items from the order
            remaining_items = [item for item in order['CartItems'] if item['MerchantID'] != merchant_id]
            
            # Update the order in DynamoDB with the remaining items
            orders_table.update_item(
                Key={'OrderID': order_id, 'UserID': order['UserID']},
                UpdateExpression="SET CartItems = :remaining_items",
                ExpressionAttributeValues={':remaining_items': remaining_items}
            )
            return {
                'statusCode': 200,
                'body': json.dumps({'message': f'Merchant items from Order {order_id} deleted successfully.'})
            }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'Error deleting merchant items from order', 'error': str(e)})
        }



####################################################################
CartFunction
####################################################################
import json
import boto3
from decimal import Decimal

# Initialize DynamoDB resource
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Carts')

# def lambda_handler(event, context):
#     method = event['httpMethod']
#     user_id = event['pathParameters']['user_id']

#     if method == 'POST':
#         body = json.loads(event['body'])
#         action = body.get('action', 'add')  
#         if action == 'add':
#             return add_to_cart(event, user_id)
#         elif action == 'update':
#             return update_cart_item(event, user_id)
#     elif method == 'GET':
#         return get_cart(user_id)
#     elif method == 'DELETE':
#         return remove_cart_item(event, user_id)

#     return {
#         'statusCode': 400,
#         'body': json.dumps({'message': 'Unsupported HTTP method'})
#     }
    
def lambda_handler(event, context):
    method = event['httpMethod']
    user_id = event['pathParameters']['user_id']

    if method == 'POST':
        return add_to_cart(event, user_id)
    elif method == 'PUT':
            return update_cart_item(event, user_id)
    elif method == 'GET':
        return get_cart(user_id)
    elif method == 'DELETE':
        return remove_cart_item(event, user_id)

    return {
        'statusCode': 400,
        'body': json.dumps({'message': 'Unsupported HTTP method'})
    }

def add_to_cart(event, user_id):
    try:
        # Parse the request body
        body = json.loads(event['body'])
        user_id = body.get('userId')
        user_name = body.get('userName')
        product_id = body.get('productId')
        quantity = int(body.get('quantity'))
        price = Decimal(str(body.get('price')))  # Convert price to Decimal
        product_name = body.get('productName')  # Extract product name
        image_url = body.get('imageUrl')  # Extract product image URL
        merchant_id = body.get('merchantId')
        merchant_name = body.get('merchantName')

        # Validate input
        if not product_id or quantity <= 0:
            return {
                'statusCode': 400,
                'body': json.dumps({'message': 'Invalid product or quantity'})
            }

        # Add the item to the cart (upsert behavior)
        table.put_item(
            Item={
                'UserID': user_id,
                'UserName': user_name,
                'ProductID': product_id,
                'ProductName': product_name,  # Store the product name
                'ImageUrl': image_url,  # Store the product image URL
                'Quantity': quantity,
                'Price': price,  # Use Decimal type for DynamoDB
                'MerchantID': merchant_id,
                'MerchantName': merchant_name
            }
        )

        return {
            'statusCode': 200,
            'body': json.dumps({'message': 'Item added to cart'})
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f"Error adding item to cart: {str(e)}"})
        }

def update_cart_item(event, user_id):
    try:
        # Parse the request body
        body = json.loads(event['body'])
        product_id = body.get('productId')
        new_quantity = int(body.get('quantity'))

        # Validate input
        if not product_id or new_quantity <= 0:
            return {
                'statusCode': 400,
                'body': json.dumps({'message': 'Invalid product or quantity'})
            }

        # Update the quantity of the product in the cart
        response = table.update_item(
            Key={
                'UserID': user_id,
                'ProductID': product_id
            },
            UpdateExpression='SET Quantity = :q',
            ExpressionAttributeValues={':q': Decimal(new_quantity)},
            ReturnValues='UPDATED_NEW'
        )

        return {
            'statusCode': 200,
            'body': json.dumps({'message': 'Cart item updated successfully'})
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f"Error updating cart item: {str(e)}"})
        }

def get_cart(user_id):
    try:
        # Fetch cart items for the user
        response = table.query(
            KeyConditionExpression=boto3.dynamodb.conditions.Key('UserID').eq(user_id)
        )
        items = response.get('Items', [])
        return {
            'statusCode': 200,
            'body': json.dumps(items, default=str)
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f"Error fetching cart: {str(e)}"})
        }

def remove_cart_item(event, user_id):
    try:
        product_id = event['pathParameters']['product_id']

        # Remove the item from the cart using the user_id and product_id
        response = table.delete_item(
            Key={
                'UserID': user_id,  # Correct case-sensitive key
                'ProductID': product_id  # Correct case-sensitive key
            }
        )

        # Check if the item was successfully deleted (optional check)
        if response.get('ResponseMetadata', {}).get('HTTPStatusCode') == 200:
            return {
                'statusCode': 200,
                'body': json.dumps({'message': 'Item removed from cart'})
            }
        else:
            return {
                'statusCode': 500,
                'body': json.dumps({'message': 'Failed to remove item from cart'})
            }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f"Error removing item from cart: {str(e)}"})
        }




####################################################################
UserAuthFunction
####################################################################
# import json
# import boto3
# import hashlib
# import uuid
# from datetime import datetime

# # Initialize DynamoDB
# dynamodb = boto3.resource('dynamodb')
# table = dynamodb.Table('Users')

# def lambda_handler(event, context):
#     try:
#         # Log the incoming event for debugging
#         print(f"Event: {json.dumps(event)}")

#         # Ensure the request is a POST request
#         if event.get('httpMethod') != 'POST':
#             return {
#                 'statusCode': 400,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*',
#                     'Access-Control-Allow-Methods': 'POST',
#                     'Access-Control-Allow-Headers': 'Content-Type'
#                 },
#                 'body': json.dumps({'message': 'Unsupported HTTP method'})
#             }

#         # Parse the request body
#         if 'body' not in event or not event['body']:
#             return {
#                 'statusCode': 400,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*',
#                     'Access-Control-Allow-Methods': 'POST',
#                     'Access-Control-Allow-Headers': 'Content-Type'
#                 },
#                 'body': json.dumps({'message': 'Request body is missing'})
#             }

#         body = json.loads(event['body'])  # Parse body content
#         print(f"Parsed Body: {body}")

#         # **Registration Flow**
#         if body['action'] == 'register':
#             username = body.get('Username')
#             password = body.get('Password')
#             email = body.get('Email')
#             role = body.get('Role', 'customer')  # Default role is customer

#             # Check if Username already exists
#             response = table.scan(
#                 FilterExpression=boto3.dynamodb.conditions.Attr('Username').eq(username)
#             )
#             if response.get('Items'):
#                 return {
#                     'statusCode': 400,
#                     'headers': {
#                         'Access-Control-Allow-Origin': '*',
#                         'Access-Control-Allow-Methods': 'POST',
#                         'Access-Control-Allow-Headers': 'Content-Type'
#                     },
#                     'body': json.dumps({'message': 'Username already exists'})
#                 }

#             # Generate a new unique UserID and hash the password
#             user_id = str(uuid.uuid4())
#             password_hash = hashlib.sha256(password.encode('utf-8')).hexdigest()

#             # Add the user to DynamoDB
#             table.put_item(
#                 Item={
#                     'UserID': user_id,
#                     'Username': username,
#                     'PasswordHash': password_hash,
#                     'Email': email,
#                     'Role': role,
#                     'CreatedAt': datetime.utcnow().isoformat()
#                 }
#             )

#             return {
#                 'statusCode': 201,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*',
#                     'Access-Control-Allow-Methods': 'POST',
#                     'Access-Control-Allow-Headers': 'Content-Type'
#                 },
#                 'body': json.dumps({'message': 'User registered successfully', 'UserID': user_id})
#             }

#         # **Login Flow**
#         elif body['action'] == 'login':
#             username = body.get('Username')
#             password = body.get('Password')

#             # Query DynamoDB for the user
#             response = table.scan(
#                 FilterExpression=boto3.dynamodb.conditions.Attr('Username').eq(username)
#             )

#             if not response.get('Items'):
#                 return {
#                     'statusCode': 400,
#                     'headers': {
#                         'Access-Control-Allow-Origin': '*',
#                         'Access-Control-Allow-Methods': 'POST',
#                         'Access-Control-Allow-Headers': 'Content-Type'
#                     },
#                     'body': json.dumps({'message': 'Invalid username or password'})
#                 }

#             user = response['Items'][0]
#             hashed_password = hashlib.sha256(password.encode('utf-8')).hexdigest()

#             if hashed_password == user['PasswordHash']:
#                 return {
#                     'statusCode': 200,
#                     'headers': {
#                         'Access-Control-Allow-Origin': '*',
#                         'Access-Control-Allow-Methods': 'POST',
#                         'Access-Control-Allow-Headers': 'Content-Type'
#                     },
#                     'body': json.dumps({'message': 'Login successful', 'UserID': user['UserID'], 'Role': user['Role']})
#                 }
#             else:
#                 return {
#                     'statusCode': 400,
#                     'headers': {
#                         'Access-Control-Allow-Origin': '*',
#                         'Access-Control-Allow-Methods': 'POST',
#                         'Access-Control-Allow-Headers': 'Content-Type'
#                     },
#                     'body': json.dumps({'message': 'Invalid username or password'})
#                 }

#         else:
#             return {
#                 'statusCode': 400,
#                 'headers': {
#                     'Access-Control-Allow-Origin': '*',
#                     'Access-Control-Allow-Methods': 'POST',
#                     'Access-Control-Allow-Headers': 'Content-Type'
#                 },
#                 'body': json.dumps({'message': 'Invalid action'})
#             }

#     except Exception as e:
#         # Log any exception for debugging
#         print(f"Error: {str(e)}")
#         return {
#             'statusCode': 500,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Access-Control-Allow-Methods': 'POST',
#                 'Access-Control-Allow-Headers': 'Content-Type'
#             },
#             'body': json.dumps({'message': f'Error processing request: {str(e)}'})
#         }



# ##############################################################################
# import json
# import boto3
# import hashlib
# import uuid
# from datetime import datetime

# # Initialize DynamoDB
# dynamodb = boto3.resource('dynamodb')
# table = dynamodb.Table('Users')

# def lambda_handler(event, context):
#     try:
#         # Log the incoming event for debugging
#         print(f"Event: {json.dumps(event)}")

#         # Ensure the request method is supported
#         if event.get('httpMethod') == 'POST':
#             body = json.loads(event['body']) if 'body' in event and event['body'] else {}
#             action = body.get('action', '')

#             if action == 'register':
#                 return register_user(body)
#             elif action == 'login':
#                 return login_user(body)
#             elif action == 'update_billing':
#                 # Use .get to safely access path parameters and avoid KeyError
#                 user_id = event['pathParameters'].get('user_id')
#                 if not user_id:
#                     raise KeyError("user_id is missing in path parameters")
#                 return update_billing_info(user_id, body)
#             else:
#                 return invalid_action_response()

#         elif event.get('httpMethod') == 'GET':
#             user_id = event['pathParameters'].get('user_id')
#             if not user_id:
#                 raise KeyError("user_id is missing in path parameters")
#             return get_user_info(user_id)

#         else:
#             return unsupported_method_response()

#     except KeyError as e:
#         return {
#             'statusCode': 400,
#             'headers': default_headers(),
#             'body': json.dumps({'message': f'Missing parameter: {str(e)}'})
#         }
#     except Exception as e:
#         # Log any exception for debugging
#         print(f"Error: {str(e)}")
#         return {
#             'statusCode': 500,
#             'headers': default_headers(),
#             'body': json.dumps({'message': f'Error processing request: {str(e)}'})
#         }


# # Helper function to return default headers
# def default_headers():
#     return {
#         'Access-Control-Allow-Origin': '*',
#         'Access-Control-Allow-Methods': 'POST, GET',
#         'Access-Control-Allow-Headers': 'Content-Type'
#     }

# # Helper functions for specific responses
# def invalid_action_response():
#     return {
#         'statusCode': 400,
#         'headers': default_headers(),
#         'body': json.dumps({'message': 'Invalid action'})
#     }

# def unsupported_method_response():
#     return {
#         'statusCode': 400,
#         'headers': default_headers(),
#         'body': json.dumps({'message': 'Unsupported HTTP method'})
#     }

# def register_user(body):
#     username = body.get('Username')
#     password = body.get('Password')
#     email = body.get('Email')
#     role = body.get('Role', 'customer')  # Default role is customer

#     # Check if Username already exists
#     response = table.scan(
#         FilterExpression=boto3.dynamodb.conditions.Attr('Username').eq(username)
#     )
#     if response.get('Items'):
#         return {
#             'statusCode': 400,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Access-Control-Allow-Methods': 'POST',
#                 'Access-Control-Allow-Headers': 'Content-Type'
#             },
#             'body': json.dumps({'message': 'Username already exists'})
#         }

#     # Generate a new unique UserID and hash the password
#     user_id = str(uuid.uuid4())
#     password_hash = hashlib.sha256(password.encode('utf-8')).hexdigest()

#     # Add the user to DynamoDB
#     table.put_item(
#         Item={
#             'UserID': user_id,
#             'Username': username,
#             'PasswordHash': password_hash,
#             'Email': email,
#             'Role': role,
#             'CreatedAt': datetime.utcnow().isoformat()
#         }
#     )

#     return {
#         'statusCode': 201,
#         'headers': {
#             'Access-Control-Allow-Origin': '*',
#             'Access-Control-Allow-Methods': 'POST',
#             'Access-Control-Allow-Headers': 'Content-Type'
#         },
#         'body': json.dumps({'message': 'User registered successfully', 'UserID': user_id})
#     }

# def login_user(body):
#     username = body.get('Username')
#     password = body.get('Password')

#     # Query DynamoDB for the user
#     response = table.scan(
#         FilterExpression=boto3.dynamodb.conditions.Attr('Username').eq(username)
#     )

#     if not response.get('Items'):
#         return {
#             'statusCode': 400,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Access-Control-Allow-Methods': 'POST',
#                 'Access-Control-Allow-Headers': 'Content-Type'
#             },
#             'body': json.dumps({'message': 'Invalid username or password'})
#         }

#     user = response['Items'][0]
#     hashed_password = hashlib.sha256(password.encode('utf-8')).hexdigest()

#     if hashed_password == user['PasswordHash']:
#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Access-Control-Allow-Methods': 'POST',
#                 'Access-Control-Allow-Headers': 'Content-Type'
#             },
#             'body': json.dumps({'message': 'Login successful', 'UserID': user['UserID'], 'Role': user['Role']})
#         }
#     else:
#         return {
#             'statusCode': 400,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Access-Control-Allow-Methods': 'POST',
#                 'Access-Control-Allow-Headers': 'Content-Type'
#             },
#             'body': json.dumps({'message': 'Invalid username or password'})
#         }

# def update_billing_info(user_id, body):
#     name = body.get('name')
#     address = body.get('address')
#     email = body.get('email')
#     payment_method = body.get('payment_method')

#     # Update the billing info in DynamoDB
#     table.update_item(
#         Key={'UserID': user_id},
#         UpdateExpression="SET #name=:n, #address=:a, #email=:e, #payment_method=:pm",
#         ExpressionAttributeNames={
#             '#name': 'Name',
#             '#address': 'Address',
#             '#email': 'Email',
#             '#payment_method': 'PaymentMethod'
#         },
#         ExpressionAttributeValues={
#             ':n': name,
#             ':a': address,
#             ':e': email,
#             ':pm': payment_method
#         }
#     )

#     return {
#         'statusCode': 200,
#         'headers': {
#             'Access-Control-Allow-Origin': '*',
#             'Access-Control-Allow-Methods': 'POST',
#             'Access-Control-Allow-Headers': 'Content-Type'
#         },
#         'body': json.dumps({'message': 'Billing information updated successfully'})
#     }

# def get_user_info(user_id):
#     response = table.get_item(Key={'UserID': user_id})

#     if 'Item' in response:
#         return {
#             'statusCode': 200,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Access-Control-Allow-Methods': 'GET',
#                 'Access-Control-Allow-Headers': 'Content-Type'
#             },
#             'body': json.dumps(response['Item'])
#         }
#     else:
#         return {
#             'statusCode': 404,
#             'headers': {
#                 'Access-Control-Allow-Origin': '*',
#                 'Access-Control-Allow-Methods': 'GET',
#                 'Access-Control-Allow-Headers': 'Content-Type'
#             },
#             'body': json.dumps({'message': 'User not found'})
#         }



import json
import boto3
import hashlib
import uuid
from datetime import datetime

# Initialize DynamoDB
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Users')

def lambda_handler(event, context):
    try:
        # Log the incoming event for debugging
        print(f"Event: {json.dumps(event)}")
        http_method = event.get('httpMethod')

        # Ensure the request method is supported
        if http_method == 'POST':
            body = json.loads(event['body']) if 'body' in event and event['body'] else {}
            action = body.get('action', '')

            if action == 'register':
                return register_user(body)
            elif action == 'login':
                return login_user(body)
            elif action == 'update_billing':
                # Use .get to safely access path parameters and avoid KeyError
                user_id = event['pathParameters'].get('user_id')
                if not user_id:
                    raise KeyError("user_id is missing in path parameters")
                return update_billing_info(user_id, body)
            else:
                return invalid_action_response()
                
        elif http_method == 'PATCH':
            user_id = event['pathParameters'].get('user_id')
            body = json.loads(event['body'])
            return update_user_info(user_id, body)

        elif http_method == 'GET':
            user_id = event['pathParameters'].get('user_id')
            if not user_id:
                raise KeyError("user_id is missing in path parameters")
            return get_user_info(user_id)

        else:
            return unsupported_method_response()

    except KeyError as e:
        return {
            'statusCode': 400,
            'headers': default_headers(),
            'body': json.dumps({'message': f'Missing parameter: {str(e)}'})
        }
    except Exception as e:
        # Log any exception for debugging
        print(f"Error: {str(e)}")
        return {
            'statusCode': 500,
            'headers': default_headers(),
            'body': json.dumps({'message': f'Error processing request: {str(e)}'})
        }

# Helper function to return default headers
def default_headers():
    return {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, GET',
        'Access-Control-Allow-Headers': 'Content-Type'
    }

# Helper functions for specific responses
def invalid_action_response():
    return {
        'statusCode': 400,
        'headers': default_headers(),
        'body': json.dumps({'message': 'Invalid action'})
    }

def unsupported_method_response():
    return {
        'statusCode': 400,
        'headers': default_headers(),
        'body': json.dumps({'message': 'Unsupported HTTP method'})
    }

def register_user(body):
    username = body.get('Username')
    password = body.get('Password')
    email = body.get('Email')
    role = body.get('Role', 'customer')  # Default role is customer

    # Check if Username already exists
    response = table.scan(
        FilterExpression=boto3.dynamodb.conditions.Attr('Username').eq(username)
    )
    if response.get('Items'):
        return {
            'statusCode': 400,
            'headers': default_headers(),
            'body': json.dumps({'message': 'Username already exists'})
        }

    # Generate a new unique UserID and hash the password
    user_id = str(uuid.uuid4())
    password_hash = hashlib.sha256(password.encode('utf-8')).hexdigest()

    # Add the user to DynamoDB
    table.put_item(
        Item={
            'UserID': user_id,
            'Username': username,
            'PasswordHash': password_hash,
            'Email': email,
            'Role': role,
            'CreatedAt': datetime.utcnow().isoformat()
        }
    )

    return {
        'statusCode': 201,
        'headers': default_headers(),
        'body': json.dumps({'message': 'User registered successfully', 'UserID': user_id})
    }

def login_user(body):
    username = body.get('Username')
    password = body.get('Password')

    # Query DynamoDB for the user
    response = table.scan(
        FilterExpression=boto3.dynamodb.conditions.Attr('Username').eq(username)
    )

    if not response.get('Items'):
        return {
            'statusCode': 400,
            'headers': default_headers(),
            'body': json.dumps({'message': 'Invalid username or password'})
        }

    user = response['Items'][0]
    hashed_password = hashlib.sha256(password.encode('utf-8')).hexdigest()

    if hashed_password == user['PasswordHash']:
        return {
            'statusCode': 200,
            'headers': default_headers(),
            'body': json.dumps({'message': 'Login successful', 'UserID': user['UserID'], 'Role': user['Role']})
        }
    else:
        return {
            'statusCode': 400,
            'headers': default_headers(),
            'body': json.dumps({'message': 'Invalid username or password'})
        }


def get_user_info(user_id):
    response = table.get_item(Key={'UserID': user_id})

    if 'Item' in response:
        return {
            'statusCode': 200,
            'headers': default_headers(),
            'body': json.dumps(response['Item'])
        }
    else:
        return {
            'statusCode': 404,
            'headers': default_headers(),
            'body': json.dumps({'message': 'User not found'})
        }

def update_user_info(user_id, body):
    # Update user details
    table.update_item(
        Key={'UserID': user_id},
        UpdateExpression="SET Username=:n, Email=:e, Address=:a, PaymentMethod=:p",
        ExpressionAttributeValues={
            ':n': body.get('name', ''),
            ':e': body.get('email', ''),
            ':a': body.get('address', ''),
            ':p': body.get('payment_method', '')
        }
    )
    return {
        'statusCode': 200,
        'headers': default_headers(),
        'body': json.dumps({'message': 'User information updated successfully'})
    }
    
# def update_billing_info(user_id, body):
#     name = body.get('name')
#     address = body.get('address')
#     email = body.get('email')
#     payment_method = body.get('payment_method')

#     # Update the billing info in DynamoDB
#     table.update_item(
#         Key={'UserID': user_id},
#         UpdateExpression="SET #name=:n, #address=:a, #email=:e, #payment_method=:pm",
#         ExpressionAttributeNames={
#             '#name': 'Name',
#             '#address': 'Address',
#             '#email': 'Email',
#             '#payment_method': 'PaymentMethod'
#         },
#         ExpressionAttributeValues={
#             ':n': name,
#             ':a': address,
#             ':e': email,
#             ':pm': payment_method
#         }
#     )

#     return {
#         'statusCode': 200,
#         'headers': default_headers(),
#         'body': json.dumps({'message': 'Billing information updated successfully'})
#     }

